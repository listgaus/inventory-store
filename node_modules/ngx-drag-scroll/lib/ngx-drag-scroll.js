import { ElementRef, Component, Renderer2, Input, Output, EventEmitter, ViewChild, ContentChildren, QueryList } from '@angular/core';
import { DragScrollItemDirective } from './ngx-drag-scroll-item';
export class DragScrollComponent {
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._scrollbarHidden = false;
        this._disabled = false;
        this._xDisabled = false;
        this._yDisabled = false;
        this._dragDisabled = false;
        this._snapDisabled = false;
        this._snapOffset = 0;
        this.isPressed = false;
        this.isScrolling = false;
        this.scrollTimer = -1;
        this.scrollToTimer = -1;
        this.downX = 0;
        this.downY = 0;
        this.displayType = 'block';
        this.elWidth = null;
        this.elHeight = null;
        this.parentNode = null;
        this.wrapper = null;
        this.scrollbarWidth = null;
        this.currIndex = 0;
        this.isAnimating = false;
        this.scrollReachesRightEnd = false;
        this.prevChildrenLength = 0;
        this.reachesLeftBound = new EventEmitter();
        this.reachesRightBound = new EventEmitter();
        this.scrollbarWidth = `${this.getScrollbarWidth()}px`;
    }
    get scrollbarHidden() { return this._scrollbarHidden; }
    set scrollbarHidden(value) { this._scrollbarHidden = value; }
    get disabled() { return this._disabled; }
    set disabled(value) { this._disabled = value; }
    get xDisabled() { return this._xDisabled; }
    set xDisabled(value) { this._xDisabled = value; }
    get yDisabled() { return this._yDisabled; }
    set yDisabled(value) { this._yDisabled = value; }
    get dragDisabled() { return this._dragDisabled; }
    set dragDisabled(value) { this._dragDisabled = value; }
    get snapDisabled() { return this._snapDisabled; }
    set snapDisabled(value) { this._snapDisabled = value; }
    get snapOffset() { return this._snapOffset; }
    set snapOffset(value) { this._snapOffset = value; }
    ngOnChanges() {
        this.setScrollBar();
        if (this.xDisabled || this.disabled) {
            this.disableScroll('x');
        }
        else {
            this.enableScroll('x');
        }
        if (this.yDisabled || this.disabled) {
            this.disableScroll('y');
        }
        else {
            this.enableScroll('y');
        }
    }
    ngAfterViewInit() {
        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'true');
        this.displayType = window.getComputedStyle(this._elementRef.nativeElement).display;
        this._renderer.setStyle(this._contentRef.nativeElement, 'display', this.displayType);
        this._renderer.setStyle(this._contentRef.nativeElement, 'whiteSpace', 'noWrap');
        this.markElDimension();
        this._renderer.setStyle(this._contentRef.nativeElement, 'width', this.elWidth);
        this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.elHeight);
        if (this.wrapper) {
            this.checkScrollbar();
        }
        this._renderer.listen(this._contentRef.nativeElement, 'mousedown', this.onMouseDownHandler.bind(this));
        this._renderer.listen(this._contentRef.nativeElement, 'scroll', this.onScrollHandler.bind(this));
        this._renderer.listen('document', 'mousemove', this.onMouseMoveHandler.bind(this));
        this._renderer.listen('document', 'mouseup', this.onMouseUpHandler.bind(this));
        this._renderer.listen('document', 'dragstart', (e) => {
            e.preventDefault();
        });
        this.checkNavStatus();
    }
    ngAfterViewChecked() {
        if (this._children['_results'].length !== this.prevChildrenLength) {
            this.markElDimension();
            this.checkScrollbar();
            this.prevChildrenLength = this._children['_results'].length;
            this.checkNavStatus();
        }
    }
    ngOnDestroy() {
        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'false');
    }
    onMouseMoveHandler(event) {
        if (this.isPressed && !this.disabled) {
            if (!this.xDisabled && !this.dragDisabled) {
                this._contentRef.nativeElement.scrollLeft =
                    this._contentRef.nativeElement.scrollLeft - event.clientX + this.downX;
                this.downX = event.clientX;
            }
            if (!this.yDisabled && !this.dragDisabled) {
                this._contentRef.nativeElement.scrollTop =
                    this._contentRef.nativeElement.scrollTop - event.clientY + this.downY;
                this.downY = event.clientY;
            }
        }
    }
    onMouseDownHandler(event) {
        this.isPressed = true;
        this.downX = event.clientX;
        this.downY = event.clientY;
        clearTimeout(this.scrollToTimer);
    }
    onScrollHandler(event) {
        const scrollLeftPos = this._contentRef.nativeElement.scrollLeft + this._contentRef.nativeElement.offsetWidth;
        if (scrollLeftPos >= this._contentRef.nativeElement.scrollWidth) {
            this.scrollReachesRightEnd = true;
        }
        else {
            this.scrollReachesRightEnd = false;
        }
        this.checkNavStatus();
        if (!this.isPressed && !this.isAnimating && !this.snapDisabled) {
            this.isScrolling = true;
            clearTimeout(this.scrollTimer);
            this.scrollTimer = window.setTimeout(() => {
                this.isScrolling = false;
                this.locateCurrentIndex(true);
            }, 500);
        }
        else {
            this.locateCurrentIndex();
        }
    }
    onMouseUpHandler(event) {
        if (this.isPressed) {
            this.isPressed = false;
            if (!this.snapDisabled) {
                this.locateCurrentIndex(true);
            }
            else {
                this.locateCurrentIndex();
            }
        }
    }
    moveLeft() {
        if (this.currIndex !== 0 || this.snapDisabled) {
            this.currIndex--;
            clearTimeout(this.scrollToTimer);
            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);
        }
    }
    moveRight() {
        if (!this.scrollReachesRightEnd && this._children['_results'][this.currIndex + 1]) {
            this.currIndex++;
            clearTimeout(this.scrollToTimer);
            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);
        }
    }
    moveTo(index) {
        if (index >= 0 &&
            index !== this.currIndex &&
            this._children &&
            this._children['_results'] &&
            this._children['_results'][index]) {
            this.currIndex = index;
            clearTimeout(this.scrollToTimer);
            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);
        }
    }
    checkNavStatus() {
        let childrenWidth = 0;
        for (let i = 0; i < this._children['_results'].length; i++) {
            childrenWidth += this._children['_results'][i]._elementRef.nativeElement.clientWidth;
        }
        setTimeout(() => {
            const onlyOneItem = Boolean(this._children['_results'].length <= 1);
            const containerIsLargerThanContent = Boolean(this._contentRef.nativeElement.scrollWidth <=
                this._contentRef.nativeElement.clientWidth);
            if (onlyOneItem || containerIsLargerThanContent) {
                this.reachesLeftBound.emit(true);
                this.reachesRightBound.emit(true);
            }
            else if (this.scrollReachesRightEnd) {
                this.reachesLeftBound.emit(false);
                this.reachesRightBound.emit(true);
            }
            else if (this._contentRef.nativeElement.scrollLeft === 0 &&
                this._contentRef.nativeElement.scrollWidth > this._contentRef.nativeElement.clientWidth) {
                this.reachesLeftBound.emit(true);
                this.reachesRightBound.emit(false);
            }
            else {
                this.reachesLeftBound.emit(false);
                this.reachesRightBound.emit(false);
            }
        }, 0);
    }
    disableScroll(axis) {
        this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'hidden');
    }
    enableScroll(axis) {
        this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'auto');
    }
    hideScrollbar() {
        if (this._contentRef.nativeElement.style.display !== 'none' && !this.wrapper) {
            this.parentNode = this._contentRef.nativeElement.parentNode;
            this.wrapper = this._renderer.createElement('div');
            this._renderer.setAttribute(this.wrapper, 'class', 'drag-scroll-wrapper');
            this._renderer.addClass(this.wrapper, 'drag-scroll-container');
            this._renderer.setStyle(this.wrapper, 'width', '100%');
            this._renderer.setStyle(this.wrapper, 'height', this._elementRef.nativeElement.style.height
                || this._elementRef.nativeElement.offsetHeight + 'px');
            this._renderer.setStyle(this.wrapper, 'overflow', 'hidden');
            this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);
            this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`);
            this._renderer.appendChild(this._elementRef.nativeElement, this.wrapper);
            this._renderer.appendChild(this.wrapper, this._contentRef.nativeElement);
        }
    }
    showScrollbar() {
        if (this.wrapper) {
            this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');
            this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.wrapper.style.height);
            if (this.parentNode !== null) {
                this.parentNode.removeChild(this.wrapper);
                this.parentNode.appendChild(this._contentRef.nativeElement);
            }
            this.wrapper = null;
        }
    }
    checkScrollbar() {
        if (this._contentRef.nativeElement.scrollWidth <= this._contentRef.nativeElement.clientWidth) {
            this._renderer.setStyle(this._contentRef.nativeElement, 'height', '100%');
        }
        else {
            this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`);
        }
        if (this._contentRef.nativeElement.scrollHeight <= this._contentRef.nativeElement.clientHeight) {
            this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');
        }
        else {
            this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);
        }
    }
    setScrollBar() {
        if (this.scrollbarHidden) {
            this.hideScrollbar();
        }
        else {
            this.showScrollbar();
        }
    }
    getScrollbarWidth() {
        const outer = this._renderer.createElement('div');
        this._renderer.setStyle(outer, 'visibility', 'hidden');
        this._renderer.setStyle(outer, 'width', '100px');
        this._renderer.setStyle(outer, 'msOverflowStyle', 'scrollbar');
        this._renderer.appendChild(document.body, outer);
        const widthNoScroll = outer.offsetWidth;
        this._renderer.setStyle(outer, 'overflow', 'scroll');
        const inner = this._renderer.createElement('div');
        this._renderer.setStyle(inner, 'width', '100%');
        this._renderer.appendChild(outer, inner);
        const widthWithScroll = inner.offsetWidth;
        this._renderer.removeChild(document.body, outer);
        return widthNoScroll - widthWithScroll || 20;
    }
    scrollTo(element, to, duration) {
        const self = this;
        self.isAnimating = true;
        const start = element.scrollLeft, change = to - start - this.snapOffset, increment = 20;
        let currentTime = 0;
        const easeInOutQuad = function (t, b, c, d) {
            t /= d / 2;
            if (t < 1) {
                return c / 2 * t * t + b;
            }
            t--;
            return -c / 2 * (t * (t - 2) - 1) + b;
        };
        const animateScroll = function () {
            currentTime += increment;
            element.scrollLeft = easeInOutQuad(currentTime, start, change, duration);
            if (currentTime < duration) {
                self.scrollToTimer = window.setTimeout(animateScroll, increment);
            }
            else {
                setTimeout(() => {
                    self.isAnimating = false;
                }, increment);
            }
        };
        animateScroll();
    }
    locateCurrentIndex(snap) {
        this.currentChildWidth((currentClildWidth, nextChildrenWidth, childrenWidth, idx, stop) => {
            if (this._contentRef.nativeElement.scrollLeft >= childrenWidth &&
                this._contentRef.nativeElement.scrollLeft <= nextChildrenWidth) {
                if (nextChildrenWidth - this._contentRef.nativeElement.scrollLeft > currentClildWidth / 2 && !this.scrollReachesRightEnd) {
                    this.currIndex = idx;
                    if (snap) {
                        this.scrollTo(this._contentRef.nativeElement, childrenWidth, 500);
                    }
                }
                else {
                    this.currIndex = idx + 1;
                    if (snap) {
                        this.scrollTo(this._contentRef.nativeElement, childrenWidth + currentClildWidth, 500);
                    }
                }
                stop();
            }
        });
    }
    currentChildWidth(cb) {
        let childrenWidth = 0;
        let shouldBreak = false;
        const breakFunc = function () {
            shouldBreak = true;
        };
        for (let i = 0; i < this._children['_results'].length; i++) {
            if (i === this._children['_results'].length - 1) {
                this.currIndex = i;
                break;
            }
            if (shouldBreak) {
                break;
            }
            const nextChildrenWidth = childrenWidth + this._children['_results'][i + 1]._elementRef.nativeElement.clientWidth;
            const currentClildWidth = this._children['_results'][i]._elementRef.nativeElement.clientWidth;
            cb(currentClildWidth, nextChildrenWidth, childrenWidth, i, breakFunc);
            childrenWidth += currentClildWidth;
        }
    }
    toChildrenLocation() {
        let to = 0;
        for (let i = 0; i < this.currIndex; i++) {
            to += this._children['_results'][i]._elementRef.nativeElement.clientWidth;
        }
        return to;
    }
    markElDimension() {
        if (this.wrapper) {
            this.elWidth = this.wrapper.style.width;
            this.elHeight = this.wrapper.style.height;
        }
        else {
            this.elWidth = this._elementRef.nativeElement.style.width || (this._elementRef.nativeElement.offsetWidth + 'px');
            this.elHeight = this._elementRef.nativeElement.style.height || (this._elementRef.nativeElement.offsetHeight + 'px');
        }
    }
}
DragScrollComponent.decorators = [
    { type: Component, args: [{
                selector: 'drag-scroll',
                template: `
    <div class="drag-scroll-content" #contentRef>
      <ng-content></ng-content>
    </div>
  `,
                styles: [`
    :host {
      overflow: hidden;
      display: block;
    }
    .drag-scroll-content {
      height: 100%;
      overflow: auto;
      white-space: nowrap;
    }
    `]
            },] },
];
DragScrollComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
DragScrollComponent.propDecorators = {
    "_contentRef": [{ type: ViewChild, args: ['contentRef',] },],
    "_children": [{ type: ContentChildren, args: [DragScrollItemDirective,] },],
    "reachesLeftBound": [{ type: Output },],
    "reachesRightBound": [{ type: Output },],
    "scrollbarHidden": [{ type: Input, args: ['scrollbar-hidden',] },],
    "disabled": [{ type: Input, args: ['drag-scroll-disabled',] },],
    "xDisabled": [{ type: Input, args: ['drag-scroll-x-disabled',] },],
    "yDisabled": [{ type: Input, args: ['drag-scroll-y-disabled',] },],
    "dragDisabled": [{ type: Input, args: ['drag-disabled',] },],
    "snapDisabled": [{ type: Input, args: ['snap-disabled',] },],
    "snapOffset": [{ type: Input, args: ['snap-offset',] },],
};
function DragScrollComponent_tsickle_Closure_declarations() {
    DragScrollComponent.decorators;
    DragScrollComponent.ctorParameters;
    DragScrollComponent.propDecorators;
    DragScrollComponent.prototype._scrollbarHidden;
    DragScrollComponent.prototype._disabled;
    DragScrollComponent.prototype._xDisabled;
    DragScrollComponent.prototype._yDisabled;
    DragScrollComponent.prototype._dragDisabled;
    DragScrollComponent.prototype._snapDisabled;
    DragScrollComponent.prototype._snapOffset;
    DragScrollComponent.prototype.isPressed;
    DragScrollComponent.prototype.isScrolling;
    DragScrollComponent.prototype.scrollTimer;
    DragScrollComponent.prototype.scrollToTimer;
    DragScrollComponent.prototype.downX;
    DragScrollComponent.prototype.downY;
    DragScrollComponent.prototype.displayType;
    DragScrollComponent.prototype.elWidth;
    DragScrollComponent.prototype.elHeight;
    DragScrollComponent.prototype.parentNode;
    DragScrollComponent.prototype._contentRef;
    DragScrollComponent.prototype._children;
    DragScrollComponent.prototype.wrapper;
    DragScrollComponent.prototype.scrollbarWidth;
    DragScrollComponent.prototype.currIndex;
    DragScrollComponent.prototype.isAnimating;
    DragScrollComponent.prototype.scrollReachesRightEnd;
    DragScrollComponent.prototype.prevChildrenLength;
    DragScrollComponent.prototype.reachesLeftBound;
    DragScrollComponent.prototype.reachesRightBound;
    DragScrollComponent.prototype._elementRef;
    DragScrollComponent.prototype._renderer;
}
//# sourceMappingURL=ngx-drag-scroll.js.map