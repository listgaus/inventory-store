{"remainingRequest":"C:\\Users\\SL\\Desktop\\greatest-books\\greatest-books\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\SL\\Desktop\\greatest-books\\greatest-books\\node_modules\\ngx-drag-scroll\\lib\\ngx-drag-scroll.js","dependencies":[{"path":"C:\\Users\\SL\\Desktop\\greatest-books\\greatest-books\\node_modules\\ngx-drag-scroll\\lib\\ngx-drag-scroll.js","mtime":1532245657164},{"path":"C:\\Users\\SL\\Desktop\\greatest-books\\greatest-books\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532245579180},{"path":"C:\\Users\\SL\\Desktop\\greatest-books\\greatest-books\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1532245544624}],"contextDependencies":[],"result":["import { ElementRef, Component, Renderer2, Input, Output, EventEmitter, ViewChild, ContentChildren } from '@angular/core';\nimport { DragScrollItemDirective } from './ngx-drag-scroll-item';\nexport class DragScrollComponent {\n    constructor(_elementRef, _renderer) {\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._scrollbarHidden = false;\n        this._disabled = false;\n        this._xDisabled = false;\n        this._yDisabled = false;\n        this._dragDisabled = false;\n        this._snapDisabled = false;\n        this._snapOffset = 0;\n        this.isPressed = false;\n        this.isScrolling = false;\n        this.scrollTimer = -1;\n        this.scrollToTimer = -1;\n        this.downX = 0;\n        this.downY = 0;\n        this.displayType = 'block';\n        this.elWidth = null;\n        this.elHeight = null;\n        this.parentNode = null;\n        this.wrapper = null;\n        this.scrollbarWidth = null;\n        this.currIndex = 0;\n        this.isAnimating = false;\n        this.scrollReachesRightEnd = false;\n        this.prevChildrenLength = 0;\n        this.reachesLeftBound = new EventEmitter();\n        this.reachesRightBound = new EventEmitter();\n        this.scrollbarWidth = `${this.getScrollbarWidth()}px`;\n    }\n    get scrollbarHidden() { return this._scrollbarHidden; }\n    set scrollbarHidden(value) { this._scrollbarHidden = value; }\n    get disabled() { return this._disabled; }\n    set disabled(value) { this._disabled = value; }\n    get xDisabled() { return this._xDisabled; }\n    set xDisabled(value) { this._xDisabled = value; }\n    get yDisabled() { return this._yDisabled; }\n    set yDisabled(value) { this._yDisabled = value; }\n    get dragDisabled() { return this._dragDisabled; }\n    set dragDisabled(value) { this._dragDisabled = value; }\n    get snapDisabled() { return this._snapDisabled; }\n    set snapDisabled(value) { this._snapDisabled = value; }\n    get snapOffset() { return this._snapOffset; }\n    set snapOffset(value) { this._snapOffset = value; }\n    ngOnChanges() {\n        this.setScrollBar();\n        if (this.xDisabled || this.disabled) {\n            this.disableScroll('x');\n        }\n        else {\n            this.enableScroll('x');\n        }\n        if (this.yDisabled || this.disabled) {\n            this.disableScroll('y');\n        }\n        else {\n            this.enableScroll('y');\n        }\n    }\n    ngAfterViewInit() {\n        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'true');\n        this.displayType = window.getComputedStyle(this._elementRef.nativeElement).display;\n        this._renderer.setStyle(this._contentRef.nativeElement, 'display', this.displayType);\n        this._renderer.setStyle(this._contentRef.nativeElement, 'whiteSpace', 'noWrap');\n        this.markElDimension();\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', this.elWidth);\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.elHeight);\n        if (this.wrapper) {\n            this.checkScrollbar();\n        }\n        this._renderer.listen(this._contentRef.nativeElement, 'mousedown', this.onMouseDownHandler.bind(this));\n        this._renderer.listen(this._contentRef.nativeElement, 'scroll', this.onScrollHandler.bind(this));\n        this._renderer.listen('document', 'mousemove', this.onMouseMoveHandler.bind(this));\n        this._renderer.listen('document', 'mouseup', this.onMouseUpHandler.bind(this));\n        this._renderer.listen('document', 'dragstart', (e) => {\n            e.preventDefault();\n        });\n        this.checkNavStatus();\n    }\n    ngAfterViewChecked() {\n        if (this._children['_results'].length !== this.prevChildrenLength) {\n            this.markElDimension();\n            this.checkScrollbar();\n            this.prevChildrenLength = this._children['_results'].length;\n            this.checkNavStatus();\n        }\n    }\n    ngOnDestroy() {\n        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'false');\n    }\n    onMouseMoveHandler(event) {\n        if (this.isPressed && !this.disabled) {\n            if (!this.xDisabled && !this.dragDisabled) {\n                this._contentRef.nativeElement.scrollLeft =\n                    this._contentRef.nativeElement.scrollLeft - event.clientX + this.downX;\n                this.downX = event.clientX;\n            }\n            if (!this.yDisabled && !this.dragDisabled) {\n                this._contentRef.nativeElement.scrollTop =\n                    this._contentRef.nativeElement.scrollTop - event.clientY + this.downY;\n                this.downY = event.clientY;\n            }\n        }\n    }\n    onMouseDownHandler(event) {\n        this.isPressed = true;\n        this.downX = event.clientX;\n        this.downY = event.clientY;\n        clearTimeout(this.scrollToTimer);\n    }\n    onScrollHandler(event) {\n        const scrollLeftPos = this._contentRef.nativeElement.scrollLeft + this._contentRef.nativeElement.offsetWidth;\n        if (scrollLeftPos >= this._contentRef.nativeElement.scrollWidth) {\n            this.scrollReachesRightEnd = true;\n        }\n        else {\n            this.scrollReachesRightEnd = false;\n        }\n        this.checkNavStatus();\n        if (!this.isPressed && !this.isAnimating && !this.snapDisabled) {\n            this.isScrolling = true;\n            clearTimeout(this.scrollTimer);\n            this.scrollTimer = window.setTimeout(() => {\n                this.isScrolling = false;\n                this.locateCurrentIndex(true);\n            }, 500);\n        }\n        else {\n            this.locateCurrentIndex();\n        }\n    }\n    onMouseUpHandler(event) {\n        if (this.isPressed) {\n            this.isPressed = false;\n            if (!this.snapDisabled) {\n                this.locateCurrentIndex(true);\n            }\n            else {\n                this.locateCurrentIndex();\n            }\n        }\n    }\n    moveLeft() {\n        if (this.currIndex !== 0 || this.snapDisabled) {\n            this.currIndex--;\n            clearTimeout(this.scrollToTimer);\n            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);\n        }\n    }\n    moveRight() {\n        if (!this.scrollReachesRightEnd && this._children['_results'][this.currIndex + 1]) {\n            this.currIndex++;\n            clearTimeout(this.scrollToTimer);\n            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);\n        }\n    }\n    moveTo(index) {\n        if (index >= 0 &&\n            index !== this.currIndex &&\n            this._children &&\n            this._children['_results'] &&\n            this._children['_results'][index]) {\n            this.currIndex = index;\n            clearTimeout(this.scrollToTimer);\n            this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), 500);\n        }\n    }\n    checkNavStatus() {\n        let childrenWidth = 0;\n        for (let i = 0; i < this._children['_results'].length; i++) {\n            childrenWidth += this._children['_results'][i]._elementRef.nativeElement.clientWidth;\n        }\n        setTimeout(() => {\n            const onlyOneItem = Boolean(this._children['_results'].length <= 1);\n            const containerIsLargerThanContent = Boolean(this._contentRef.nativeElement.scrollWidth <=\n                this._contentRef.nativeElement.clientWidth);\n            if (onlyOneItem || containerIsLargerThanContent) {\n                this.reachesLeftBound.emit(true);\n                this.reachesRightBound.emit(true);\n            }\n            else if (this.scrollReachesRightEnd) {\n                this.reachesLeftBound.emit(false);\n                this.reachesRightBound.emit(true);\n            }\n            else if (this._contentRef.nativeElement.scrollLeft === 0 &&\n                this._contentRef.nativeElement.scrollWidth > this._contentRef.nativeElement.clientWidth) {\n                this.reachesLeftBound.emit(true);\n                this.reachesRightBound.emit(false);\n            }\n            else {\n                this.reachesLeftBound.emit(false);\n                this.reachesRightBound.emit(false);\n            }\n        }, 0);\n    }\n    disableScroll(axis) {\n        this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'hidden');\n    }\n    enableScroll(axis) {\n        this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'auto');\n    }\n    hideScrollbar() {\n        if (this._contentRef.nativeElement.style.display !== 'none' && !this.wrapper) {\n            this.parentNode = this._contentRef.nativeElement.parentNode;\n            this.wrapper = this._renderer.createElement('div');\n            this._renderer.setAttribute(this.wrapper, 'class', 'drag-scroll-wrapper');\n            this._renderer.addClass(this.wrapper, 'drag-scroll-container');\n            this._renderer.setStyle(this.wrapper, 'width', '100%');\n            this._renderer.setStyle(this.wrapper, 'height', this._elementRef.nativeElement.style.height\n                || this._elementRef.nativeElement.offsetHeight + 'px');\n            this._renderer.setStyle(this.wrapper, 'overflow', 'hidden');\n            this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);\n            this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`);\n            this._renderer.appendChild(this._elementRef.nativeElement, this.wrapper);\n            this._renderer.appendChild(this.wrapper, this._contentRef.nativeElement);\n        }\n    }\n    showScrollbar() {\n        if (this.wrapper) {\n            this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n            this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.wrapper.style.height);\n            if (this.parentNode !== null) {\n                this.parentNode.removeChild(this.wrapper);\n                this.parentNode.appendChild(this._contentRef.nativeElement);\n            }\n            this.wrapper = null;\n        }\n    }\n    checkScrollbar() {\n        if (this._contentRef.nativeElement.scrollWidth <= this._contentRef.nativeElement.clientWidth) {\n            this._renderer.setStyle(this._contentRef.nativeElement, 'height', '100%');\n        }\n        else {\n            this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`);\n        }\n        if (this._contentRef.nativeElement.scrollHeight <= this._contentRef.nativeElement.clientHeight) {\n            this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n        }\n        else {\n            this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);\n        }\n    }\n    setScrollBar() {\n        if (this.scrollbarHidden) {\n            this.hideScrollbar();\n        }\n        else {\n            this.showScrollbar();\n        }\n    }\n    getScrollbarWidth() {\n        const outer = this._renderer.createElement('div');\n        this._renderer.setStyle(outer, 'visibility', 'hidden');\n        this._renderer.setStyle(outer, 'width', '100px');\n        this._renderer.setStyle(outer, 'msOverflowStyle', 'scrollbar');\n        this._renderer.appendChild(document.body, outer);\n        const widthNoScroll = outer.offsetWidth;\n        this._renderer.setStyle(outer, 'overflow', 'scroll');\n        const inner = this._renderer.createElement('div');\n        this._renderer.setStyle(inner, 'width', '100%');\n        this._renderer.appendChild(outer, inner);\n        const widthWithScroll = inner.offsetWidth;\n        this._renderer.removeChild(document.body, outer);\n        return widthNoScroll - widthWithScroll || 20;\n    }\n    scrollTo(element, to, duration) {\n        const self = this;\n        self.isAnimating = true;\n        const start = element.scrollLeft, change = to - start - this.snapOffset, increment = 20;\n        let currentTime = 0;\n        const easeInOutQuad = function (t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            t--;\n            return -c / 2 * (t * (t - 2) - 1) + b;\n        };\n        const animateScroll = function () {\n            currentTime += increment;\n            element.scrollLeft = easeInOutQuad(currentTime, start, change, duration);\n            if (currentTime < duration) {\n                self.scrollToTimer = window.setTimeout(animateScroll, increment);\n            }\n            else {\n                setTimeout(() => {\n                    self.isAnimating = false;\n                }, increment);\n            }\n        };\n        animateScroll();\n    }\n    locateCurrentIndex(snap) {\n        this.currentChildWidth((currentClildWidth, nextChildrenWidth, childrenWidth, idx, stop) => {\n            if (this._contentRef.nativeElement.scrollLeft >= childrenWidth &&\n                this._contentRef.nativeElement.scrollLeft <= nextChildrenWidth) {\n                if (nextChildrenWidth - this._contentRef.nativeElement.scrollLeft > currentClildWidth / 2 && !this.scrollReachesRightEnd) {\n                    this.currIndex = idx;\n                    if (snap) {\n                        this.scrollTo(this._contentRef.nativeElement, childrenWidth, 500);\n                    }\n                }\n                else {\n                    this.currIndex = idx + 1;\n                    if (snap) {\n                        this.scrollTo(this._contentRef.nativeElement, childrenWidth + currentClildWidth, 500);\n                    }\n                }\n                stop();\n            }\n        });\n    }\n    currentChildWidth(cb) {\n        let childrenWidth = 0;\n        let shouldBreak = false;\n        const breakFunc = function () {\n            shouldBreak = true;\n        };\n        for (let i = 0; i < this._children['_results'].length; i++) {\n            if (i === this._children['_results'].length - 1) {\n                this.currIndex = i;\n                break;\n            }\n            if (shouldBreak) {\n                break;\n            }\n            const nextChildrenWidth = childrenWidth + this._children['_results'][i + 1]._elementRef.nativeElement.clientWidth;\n            const currentClildWidth = this._children['_results'][i]._elementRef.nativeElement.clientWidth;\n            cb(currentClildWidth, nextChildrenWidth, childrenWidth, i, breakFunc);\n            childrenWidth += currentClildWidth;\n        }\n    }\n    toChildrenLocation() {\n        let to = 0;\n        for (let i = 0; i < this.currIndex; i++) {\n            to += this._children['_results'][i]._elementRef.nativeElement.clientWidth;\n        }\n        return to;\n    }\n    markElDimension() {\n        if (this.wrapper) {\n            this.elWidth = this.wrapper.style.width;\n            this.elHeight = this.wrapper.style.height;\n        }\n        else {\n            this.elWidth = this._elementRef.nativeElement.style.width || (this._elementRef.nativeElement.offsetWidth + 'px');\n            this.elHeight = this._elementRef.nativeElement.style.height || (this._elementRef.nativeElement.offsetHeight + 'px');\n        }\n    }\n}\nfunction DragScrollComponent_tsickle_Closure_declarations() {\n    DragScrollComponent.decorators;\n    DragScrollComponent.ctorParameters;\n    DragScrollComponent.propDecorators;\n    DragScrollComponent.prototype._scrollbarHidden;\n    DragScrollComponent.prototype._disabled;\n    DragScrollComponent.prototype._xDisabled;\n    DragScrollComponent.prototype._yDisabled;\n    DragScrollComponent.prototype._dragDisabled;\n    DragScrollComponent.prototype._snapDisabled;\n    DragScrollComponent.prototype._snapOffset;\n    DragScrollComponent.prototype.isPressed;\n    DragScrollComponent.prototype.isScrolling;\n    DragScrollComponent.prototype.scrollTimer;\n    DragScrollComponent.prototype.scrollToTimer;\n    DragScrollComponent.prototype.downX;\n    DragScrollComponent.prototype.downY;\n    DragScrollComponent.prototype.displayType;\n    DragScrollComponent.prototype.elWidth;\n    DragScrollComponent.prototype.elHeight;\n    DragScrollComponent.prototype.parentNode;\n    DragScrollComponent.prototype._contentRef;\n    DragScrollComponent.prototype._children;\n    DragScrollComponent.prototype.wrapper;\n    DragScrollComponent.prototype.scrollbarWidth;\n    DragScrollComponent.prototype.currIndex;\n    DragScrollComponent.prototype.isAnimating;\n    DragScrollComponent.prototype.scrollReachesRightEnd;\n    DragScrollComponent.prototype.prevChildrenLength;\n    DragScrollComponent.prototype.reachesLeftBound;\n    DragScrollComponent.prototype.reachesRightBound;\n    DragScrollComponent.prototype._elementRef;\n    DragScrollComponent.prototype._renderer;\n}\n//# sourceMappingURL=ngx-drag-scroll.js.map\n",null]}